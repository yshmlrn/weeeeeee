# APCS練習
## 程式練習
### a133: APCS 110.09 1.七言對聯
#### 題目概述
中文依照發音方式可以分為平聲與仄聲，假設我們把平聲標記為 0 而仄聲標記為 1
一個七言對聯包含兩個句子，每個句子包含恰好七個字

七言對聯有三個限制：
A: 二四不同二六同：每一句第二、四個字必須不同平仄，而第二、六個字必須相同平仄
B: 仄起平收：第一句的結尾必須為仄聲，第二句的結尾必須為平聲
C: 上下相對：第一、二句的第二、四、六個字平仄必須不同

給你 n 組對聯，分別用0, 1 代表平仄，請輸出它違反了哪幾條規則
若以上規則皆無違反，請輸出None
#### 程式碼
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
int n;
cin>>n;//輸入對聯
    for (int i=0;i<n;i++){
        int a[7],b[7];
        for (int i=0;i<7;i++){
            cin>>a[i];
        }
        for (int i=0;i<7;i++){
            cin>>b[i];
        }
        string ans="";//要記得初始化
        if (a[1]==a[3]||a[1]!=a[5]||b[1]==b[3]||b[1]!=b[5]){
            ans +="A";
        }//二四同或二六不同(陣列是從a[0]開始的，所以第二個字是a[1])
        if (a[6]==0||b[6]==1){
            ans +="B";
        }//第一行七為平或第二行七為仄
        if (a[1]==b[1]||a[3]==b[3]||a[5]==b[5]){
            ans +="C";
        }//二四六平仄同
        if (ans==""){
            cout<<"None"<<endl;
        }
        else{
            cout<<ans<<endl;
        }
    }
}
```

### a134: APCS 110.11 1.修補圍籬
#### 題目概述
有一個農場有寬度為 n 的圍籬, 每個圍籬都有各自的高度 h[1],h[2],⋯,h[n]
有些圍籬被吹斷了，農場主人要來修補這些圍籬，但他忘記這些壞掉的圍籬原本高度是多少，為了減少成本，他會取斷掉的圍籬位置相鄰左邊和右邊較小的那個高度填上去，問需要多少成本
題目保證不會有兩個相鄰的吹斷圍籬，而穿斷的圍籬有可能位在邊界
#### 程式碼
```cpp
#include<bits/stdc++.h>

using namespace std;
int main() {
    int n;
    cin>>n;
    int arr[n];
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    int ans=0;//壞掉的圍牆
    for(int i=0;i<n;i++) {
        if(arr[i]==0){//最左邊
            if(i==0) {
                ans+=arr[i+1];//隔壁的
            }
            else if(i==n-1){//最右邊
                ans+=arr[i-1];//隔壁的
            } 
            else{
                ans+=min(arr[i-1],arr[i+1]);//取比較小的補上去
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


### a153: APCS 111.06 1.數字遊戲
#### 題目概述
給三個介於 1 ~ 9 的整數 ，A1, A2, A3。
先輸出一個正整數 P 表示眾數數量，也就是出現最多次的數字的次數。
接下來將輸入的三個數字去除重複（剩下一個）後由大到小依序輸出
#### 解題思路
1. 設一個有10個位置的陣列，分別代表0~9出現的次數 (題目只會有1~9所以0用不到)
2. 變數x作為輸入的數字，假設第一個數字為5，就在a[5]的位置+1
3. 設定最大值並逐個比較，如果數字比原本的最大值大就取代
4. 從最大的數字往回輸出，如果那格的數字不是0代表需要輸出
#### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int a[10]={};
	for(int i=0;i<3;i++){
	    int x;
	    cin>>x;
	    a[x]++;
	}
	int maxn=0;
	for(int i=0;i<10;i++){
	    if(a[i]>maxn){
	        maxn=a[i];
	    }
	}
	cout<<maxn;
	for(int i=9;i>0;i--){
	    if(a[i]!=0){
	        cout<<" "<<i;
	    }
	}
}
```


### a154: APCS 111.10 1.巴士站牌
#### 題目概述
平面上有 n 個巴士站，第 i 個巴士站的位置可以用座標點 ( xi , yi ) 來表示。
兩個巴士站之間行進的時間是這兩個巴士站座標的曼哈頓距離。曼哈頓距離的定義如下：
對於兩個座標點 ( x1 , y1 ) 與 ( x2 , y2 ) ，兩點之間曼哈頓距離的為|x1 - x2| + |y1 - y2|。
你今天要從 巴士站1 坐車到 巴士站n，中間依序經過 巴士站2, 3, 4, ..., (n-1)。
請計算過程中相鄰兩站的行進時間的 最大值 與 最小值。
#### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin>>n;
	int x1,y1,x2,y2,d;
	cin>>x1>>y1;
	int maxd=0,mind=500;//隨便設一個一定能被取代的值
	for(int i=0;i<n-1;i++){
	    cin>>x2>>y2;
	    d=abs(x2-x1)+abs(y2-y1);
	    if(d>maxd){//一個一個比較，比較大就取代掉原本的數字
	        maxd=d;
	    }
	    if(d<mind){
	        mind=d;
	    }
	    x1=x2;
	    y1=y2;
	}
	cout<<maxd<<" "<<mind;
}
```


### a155: APCS 112.01 1.程式考試
#### 題目概述
給 n 個提交紀錄，第 i 個提交紀錄有兩個整數 ti 和 si 代表上傳時間和該次上傳的分數，若第 i 次的提交結果為嚴重錯誤，則 si 為 -1。
計算總分的公式為 : 提交紀錄中的最高分 - 總提交次數 - 總嚴重錯誤次數 * 2，若計算出來的分數為負數則計為 0。
請輸出總分和第一次獲得最高分的時間點。
#### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin>>n;
	int t,s,bestt=-1,bests=-1,fail=0;
	for(int i=0;i<n;i++){
	    cin>>t>>s;
	    if(s==-1){
	        fail++;
	    }
	    if(s>bests){
	        bests=s;
	        bestt=t;
	    }
	}
	int score=max(0,bests-n-fail*2);
	cout<<score<<" "<<bestt;
}
```


### a156: APCS 112.06 1.路徑偵測
#### 題目概述
給一個二維平面，座標如同數學的二維座標(Ｙ正為北，Ｘ正為東)。起始位置在 (0, 0)，接下來會有 n 個座標，你需要按照這些座標點的順序移動，保證僅會垂直或水平方向上移動，不會斜向移動，且第一個點保證一定是Ｘ軸正的位置(初始方向向右)。
請輸出這條路徑中，左轉、右轉、迴轉的個數分別為多少。
#### 解題思路
1. 設定移到下一個點時當下的方向
北方=1，東方=2，南方=3，西方=4
2. 用if-else判斷下一個點面向的方位
3. 如果下個方位比原本多1代表右轉，少1代表左轉，+2或-2代表迴轉
#### 程式碼
##### 錯誤
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n,x1,y1,x2,y2;
	cin>>n;
	cin>>x1>>y1;
	int dir=2,newdir=0;
	int L=0,R=0,Turn=0;
	for(int i=0;i<n-1;i++){
	    cin>>x2>>y2;
	    if(x1==x2){
	        if(y2>y1){
	            newdir=1;
	        }
	        else if(y2<y1){
	            newdir=3;
	        }
	    }
	    if(y1==y2){
	        if(x2>x1){
	            newdir=2;
	        }
	        else if(x2<x1){
	            newdir=4;
	        }
	    }
	    
	    if(newdir-dir==1){
	        R++;
	    }
	    if(newdir-dir==-1){
	        L++;
	    }
	    if(abs(newdir-dir)==2){
	        Turn++;
	    }
	    dir=newdir;
	    x1=x2;
	    y1=y2;
	}
	cout<<L<<" "<<R<<" "<<Turn;
}
```
##### 正確
第29行到第37行應該改成這樣：
```cpp
if(newdir-dir==1||newdir-dir==-3){
	R++;
}
if(newdir-dir==-1||newdir-dir==3){
	L++;
}
if(abs(newdir-dir)==2){
	Turn++;
}
```
避免忽略了從4(西方)變成1(北方)的情況



### a157: APCS 112.10 1.機械鼠
#### 題目概述
有 n 個位置上有食物，另外有一隻老鼠一開始位於位置 x。
老鼠在開始覓食前要選擇今天要往左邊或往右移動去尋找食物，經過食物時可以停下來吃食物，吃完後可以選擇繼續往相同方向移動，或者是結束今天的覓食。
請問老鼠最多能吃到多少個食物，以及最後停下來吃食物的位置。
#### 解題思路
1. 因為老鼠只會往一邊走，所以只需要判斷往右(比x大)比較多還是往左(比x小)比較多
2. 比較在x右邊和x左邊的各有幾個
3. 一個一個看，且如果比x大的數值又是最大的，最大值+1
#### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int x,n;
    cin>>x>>n;
    int right=0,left=0;
    int rmax=-100,lmax=100;
    int num;
    for(int i=0;i<n;i++){
        cin>>num;
        if(num>x){
            right++;
            if(num>rmax){
                rmax=num;
            }
        }
        if(num<x){
            left++;
            if(num<lmax){
                lmax=num;
            }
        }
    }
    if(right>left){
        cout<<right<<" "<<rmax;
    }
    if(right<left){
        cout<<left<<" "<<lmax;
    }
}
```


### a158: APCS 113.01 1.遊戲選角
#### 題目概述
有 n 個角色，每個角色有攻擊力和防禦力。
角色的能力值是攻擊力和防禦力的平方和，輸出能力值第二大的攻擊力和防禦力數值。
保證每個角色的能力值相異。
#### 解題思路
1. 把最大和第二大都存下來，最後輸出第二大就可以了
2. 如果新的數值比原本最大值還大，把新數字改成最大值，把本來的最大值改成第二大
3. 如果新數值比第二名還大，就直接取代第二名
#### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin>>n;
    int ai,di,mai,mdi,sai=0,sdi=0;
    cin>>mai>>mdi;
    for(int i=0;i<n-1;i++){
        cin>>ai>>di;
        if(ai*ai+di*di>sai*sai+sdi*sdi){
            if(ai*ai+di*di>mai*mai+mdi*mdi){
                sai=mai;
                sdi=mdi;
                mai=ai;
                mdi=di;
            }
            else{
                sai=ai;
                sdi=di;
            }
        }
    }
    cout<<sai<<" "<<sdi;
}
```
