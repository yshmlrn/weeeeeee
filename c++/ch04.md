---
layout: course_layout
title: "C++ CH04"
---
# CH04_二維陣列
## 課程重點
1. 邏輯上像一個表格，由列與行組成
2. a[i][j]表示第i列、第j行 
3. 用雙層for迴圈(外層跑列、內層跑行)讀取和輸出
## 程式練習(前三題因為田教所以未完成)
### a167: APCS 113.06 2.電子畫布
#### 題目概述
有一個 H×W 的電子畫布，一開始數值都是 0 代表未填色，接下來請模擬 N 次畫筆操作。
每次畫筆操作為選一個座標 (r,c) 停留 t 秒，他會將曼哈頓距離 ≤t 的區塊染上顏色 x。若有多個顏色重複填到相同區塊，顏色的數值會累加起來。
請輸出 N 次操作後的畫布狀態。



### a166: APCS 113.10 2.蒐集寶石
#### 題目概述
有一個 M*N 的地圖，每一格的數字紀錄著寶石的數量，如果數字是 -1 代表牆壁。
有一位機器人一開始位於 (r,c) 的位置上且方向朝右邊，他遵循著以下規則行走：

1. 若機器人位於的格字內寶石數量為 0，則機器人程式終止。
2. 機器人維護著一個分數 score，將 score 加上當前格的寶石數量，並且撿起一顆寶石。
3. 若 score 是 k 的倍數，則向右轉 90 度。
4. 若機器人面向的格子是牆壁或是超出邊界，則繼續向右轉 90 度直到面向的格子非牆壁或非超出邊界，並回到第 1 步。

例如機器人一開始在座標 (2,1) 且 k=2，向右走兩步之後分數為 3+2+3=8，由於 8 是 k(=2) 的倍數所以向右轉 90 度。接下來往下走一步分數變為 11，需要向右轉 2 次 90 度才不會面向牆壁或是邊界外的格子。
接下來向前走一步走到座標 (2,3)，由於先前已經拿走一顆寶石，該位置的寶石數量變為 2，因此分數變為 13，再繼續往上走兩步到 (0,3) 處分數為 16，由於 16 為 2 的倍數所以向右轉 90 度。
向前走一格到 (0,4) 後需要向右轉兩次 90 度，回到 (0,3) 後由於寶石數量為 0，機器人停止。過程中機器人總共撿了 8 顆寶石。


### a168: APCS 113.01 2.蜜蜂觀察
#### 題目概述
蜜蜂 Bob 在一個大小是 m×n 的蜂巢 (見範例說明圖示），並且每個蜂巢格上會有一個代表字母（大小或小寫英文字母）。
Bob 一開始在蜂巢左下角，行走方向定義如圖：0 是往右上; 1 是往右邊; 2 是往右下; 3 是往左下; 4 是往左邊; 5 是往左上。
輸入每步移動的方向，請輸出經過的路徑每格的代表字母，以及經過字元的種類數（大小寫相異），若經過時碰到牆壁該行動會停在原地。

第一行包含三個整數 m、n、k (1≤m,n≤20，1≤k≤100)，表示蜂巢的大小是 m×n，Bob 的行走路徑有 k 步。
接下來的 m 行，每行包含 n 個字母（大小寫英文字母），代表蜂巢的狀態。
最後一行包含 k 個整數，表示 Bob 的移動路徑方向。

輸出一行，包含兩個部分：
* 由 Bob 每步經過的每格代表字母所組成的字串。
* 經過字元的種類數（大小寫視為相異），用一個整數表示。


### a171: APCS 112.01 2.造字程式
#### 題目概述
有一個長度 K 的的初始字串 S，每個字元都是小寫的英文字母。
接下來有 Q 次的修改，每次的修改會把舊的字串重新排列成一個新的字串。
更具體來講，每次修改時會給一個 1 ~ K 的排列 P=[P1,P2,...,PK]，要將舊字串的第 i 的字元複製到新字串的第 Pi 個字元。
例子：
- 若舊字串是 "abac"，且 P=[4,1,3,2]，可以得到新字串 "bcaa"。
- 若舊字串是 "bcaa"，且 P=[1,2,3,4]，可以得到新字串 "bcaa"。
- 若舊字串是 "bcaa"，且 P=[2,3,4,1]，可以得到新字串 "abca"。

在 Q 的修改中，每次修改出來的新字串會被當成下一次修改中的舊字串，而第一次修改時使用的舊字串就是初始字串。

第一行有三個整數 K,Q,R
第二行是長度 K 的初始字串
接下來有 Q 行，每行有是一個 1~K 的排列
請依照題目敘述輸出 R×Q 個字元

#### 解題思路
1. 假設一個字串陣列，形式和二維陣列一樣，但可以存字元
2. 每次讀一個數字來改變位置
3. 題目給的是第pos個位置，但陣列從0開始，所以第15行要[pos-1]
4. 要反著輸出，所以21行要輸出[j][i]
#### 程式碼
```cpp=
#include <bits/stdc++.h>
using namespace std;

int main() {
	int k,q,r;
	cin>>k>>q>>r;
	string ori;
	cin>>ori;
	int pos;
	string a[q];
	for(int i=0;i<q;i++){
	    a[i]=ori;
	    for(int j=0;j<k;j++){
	        cin>>pos;
	        a[i][pos-1]=ori[j];
	    }
	    ori=a[i];
	}
	for(int i=0;i<r;i++){
	    for(int j=0;j<q;j++){
	        cout<<a[j][i];
	    }
	    cout<<endl;
	}
}
```
